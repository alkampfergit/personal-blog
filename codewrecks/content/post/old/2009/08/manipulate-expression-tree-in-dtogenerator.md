---
title: "Manipulate Expression Tree in DtoGenerator"
description: ""
date: 2009-08-12T02:00:37+02:00
draft: false
tags: ["Visual Studio", "LINQ"]
categories: ["Programming"]
---
I'm writing a simple [Dto generator](http://www.codewrecks.com/blog/index.php/2009/07/31/dto-generator-and-repository-integration/), and today I found a challenging problem. I supported dto composition like this:

[![image](https://www.codewrecks.com/blog/wp-content/uploads/2009/08/image-thumb19.png "image")](https://www.codewrecks.com/blog/wp-content/uploads/2009/08/image19.png)

I have a CustomerDto3 that have only CustomerId and ContactName properties, then I want to autogenerate a OrderTestDto that have a Customers property of type CustomerDto3. The syntax on My T4 generator is this one.

{{< highlight csharp "linenos=table,linenostart=1" >}}
SyntaxCode syntax = new SyntaxCode(
    @"bin\Debug\DtoFactory.Exe", 
    Path.GetDirectoryName(Host.TemplateFile),
    "DtoFactory.Dto",
    "http://dtonamespace.org");   
syntax.Render(
    "DtoFactory.Orders[OrdersTestDto] (OrderID,OrderDate,Customers) (Customers|CustomerDto3)",
    "Generated\\OrderDto3.cs"); {{< / highlight >}}

<!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com -->

I've simplified dto creation, and supported generation of each dto in a different file. The main problem supporting this scenario is *how to write the assembler of the container class*. I've started generating this code.

{{< highlight CSharp "linenos=table,linenostart=1" >}}
public static Expression<Func<Orders, OrdersTestDto>> ExpressionSelector;

static Assembler() {

ExpressionSelector = obj => new OrdersTestDto() {
        OrderDate = obj.OrderDate,
        OrderID = obj.OrderID,
        Customers = CustomerDto3.Assembler.FromOriginal(obj.Customers),
        }; {{< / highlight >}}

<!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com -->

It works perfectly, after all since all the Dto are generated by the same generator, when I have to generate code that transforms an original Orders object into an OrdersTestDto, I know that the creation of CustomerDto3 can be delegated to the assembler of CustomerDto3 object. This is good but now this code wont work.

{{< highlight CSharp "linenos=table,linenostart=1" >}}
using (NorthwindEntities context = new NorthwindEntities())
    {
        var Query = context.Orders
           .Where(o => o.Customers.CustomerID == "ALFKI")
           .Select(OrdersTestDto.Assembler.ExpressionSelector);{{< / highlight >}}

<!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com -->

If you read my older article, you find that one the most useful feature of dto generator, is the possibility to use expressions to make a projection in the database, but with previous generated Expression, Entity Framework give me this error

{{< highlight csharp "linenos=table,linenostart=1" >}}
failed: System.NotSupportedException : LINQ to Entities does not recognize the method 'DtoFactory.Dto.CustomerDto3 FromOriginal({{< / highlight >}}

<!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com -->

This is obvious, because when EF translate the ExpressionTree into SQL code, it finds a call to user function, and he cannot know how to proceed. This seems to me a really bad limitation, so I decided to fix it. The problem is that the expression should be generated this way.

{{< highlight CSharp "linenos=table,linenostart=1" >}}
public static Expression<Func<Orders, OrdersTestDto>> Expression2Selector
    = obj => new OrdersTestDto()
      {
          OrderDate = obj.OrderDate,
          OrderID = obj.OrderID,
          Customers = new CustomerDto3()
          {
            CustomerID =  obj.Customers.CustomerID,
            ContactName = obj.Customers.ContactName,
          },
      };{{< / highlight >}}

<!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com -->

With such an expression the EF provider is able to do the projection, but now a big problem arise. I'm working with T4 code generation, when the generator of OrdersTestDto has to generate the Expression, he does not know how the CustomerDto3 was generated, so he cannot generate such an expression. I really want to avoid the need to find a way to make different generators to share data.

After a brief thinking I realize that I already have the right expression built in CustomerDto3, so the only stuff I need is to compose the two expression, but this can be more complex than you can think. After lot of experiments, I came to this little trick.

{{< highlight xml "linenos=table,linenostart=1" >}}
private static void ParseSelector()
{
    ExpressionSelector = (Expression<Func<Orders, OrdersTestDto>>)
        new DtoExpressionVisitor().ReplaceDtoBinding(ExpressionSelector);
}
static Assembler() {

    ExpressionSelector =...
    ParseSelector();
}{{< / highlight >}}

<!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com -->

The trick works in this way, I generate the ExpressionSelector in the usual way, with the call to FromOriginal that does not work in EF LINQ query, but in the static constructor I call a ParseSelector function that rewrite the expression tree making it works with LINQ query :D. Here is the full code of the DtoExpressionVisitor().

{{< highlight csharp "linenos=table,linenostart=1" >}}
class DtoExpressionVisitor : ExpressionVisitor
{private ParameterExpression parameter;public Expression ReplaceDtoBinding(LambdaExpression exp){	parameter = exp.Parameters[0];	return this.Visit(exp);}
protected override System.Linq.Expressions.MemberBinding VisitBinding(System.Linq.Expressions.MemberBinding binding){	if (binding is MemberAssignment)	{		MemberAssignment assign = (MemberAssignment)binding;		if (assign.Expression is MethodCallExpression)		{			MethodCallExpression callex = (MethodCallExpression)assign.Expression;			if (callex.Arguments.Count == 1)			{				MemberExpression argument = (MemberExpression) callex.Arguments[0];				Type assembler = callex.Method.DeclaringType;				if (assembler != null)				{					//The object is a dto and it is assemblable.					FieldInfo expSelector = assembler.GetField("ExpressionSelector", BindingFlags.Static | BindingFlags.Public);					if (expSelector != null)					{						LambdaExpression lambda = (LambdaExpression)expSelector.GetValue(null);						MemberInitExpression minit = (MemberInitExpression)lambda.Body;						List<MemberBinding> bindings = new List<MemberBinding>();						foreach (MemberBinding oribind in minit.Bindings)						{							//1Â° step. access obj.Property							MemberExpression accessOriObj = Expression.Property(parameter, argument.Member.Name);							//2Â° step. access obj.Property.p'roperty							MemberExpression accessObjProperty = Expression.Property(accessOriObj, oribind.Member.Name);							//3Â° recreate the binding and store into a list							MemberBinding newPropertyBind = Expression.Bind(oribind.Member, accessObjProperty);							bindings.Add(newPropertyBind);						}						NewExpression constructor = Expression.New(((PropertyInfo) assign.Member).PropertyType);						MemberInitExpression newInitExpression = Expression.MemberInit(constructor, bindings.ToArray());						MemberBinding newBindingExpression = Expression.Bind(assign.Member, newInitExpression);						return newBindingExpression;					}				}			}		}	}	return base.VisitBinding(binding);}{{< / highlight >}}

<!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com -->

This is quite complicated code, and it works by replacing part of the original expression tree thus composing two expression tree into one. All initial conditions are needed to identify nodes that need correction, I need to correct all MemberBinding node that are MethodCallExpression, because those ones are the ones calling the FromOriginal function from the other dto. When I find a node to change, I otbain with reflection the original expression selector (a lambdaexpression), where the body is the one used to initialize the Dto. Now I have to regenerate a similar expression using the parameter of the original lambda. Basically the problem is the following, the OrdersTestDto expressionSelector has a parameter named obj of type orders, but the ExpressionSelector of CustomersDto3 has one parameter named obj but of type Customers. This means that I need to regenerate the whole ExpressionTree part, changing how parameters works.

The first step is to regenerate all MemberBinding expression part, with the original parameter (line 34-38) and storing them into a collection (line 39). The operation is the following, I need a MemberExpression that extract from the parameter the object needed to generate the Dto. In the above example accessing the Customers property of Orders to gets a Customer object. Then another MemberExpression to take the corresponding field from the Customers object, and finally a MemberBinding.

Then I need to recreate the BindingExpression (line 41-43) and returning in place of the original one. All the code is based on the [original Tree Visitor by microsoft](class%20DtoExpressionVisitor%20:%20ExpressionVisitor). With this quite complex trick I'm able to change the expression at runtime, thus keeping the generator simple.

alk.

